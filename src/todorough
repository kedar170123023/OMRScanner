todo
Try out contours and see the marker
>> Centre of that contour will be close to that center!!
>> There's also hough transform, but it aint as flexible (needs min max radius)
>> If we ARE using a specific marker like the circle, 
	Why not use a barcode? (Hint: test on perspectives)
	https://www.pyimagesearch.com/2014/11/24/detecting-barcodes-images-python-opencv/
	^We can, but now you've DECIDED to use the circle and it's a good decision, so get on with it!

^>> So, findContours seems not reliable as is. Works a bit on binarizing the image, but same prob with xeroxed image would be here. And this approach will be subject to background changes.
	
	Rather can you find the sidelines so as to determine quadrants?
	>> **Orientation can be determined by DFT
		https://docs.opencv.org/2.4/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html
	>> The sidelines are not as good markers as a filled strip!

>> Why not use a blob instead of circles? 
	- Distance of sheet from camera variable. 
	>> What if we add it to input constraint that biggest blob should be the one on OMR.

** This Sobel operator can be used for aligning the template!!
	And morphing too -
	https://docs.opencv.org/trunk/d9/d61/tutorial_py_morphological_ops.html



17 Feb
> Two layered warping - 1st page, 2nd marker.
Refactor more-
> globalized redundant arguments
> getROI and match_template_scaled. Line changes: 188 -> 152

18 Feb
> Why were you matching using eroded template?
--> Was in the blog, it was better than using gray one.
--> Seemed to remember the deeper concentric patterns, they were causing inaccurate results (many other white areas in image)
--> Binarized image be better!

20 Feb

// Tune the page cropping parameters

// Debug template matching


// Checkout this weird trick that makes marked bubbles and the template circle distinctly blobby- 
	gray = gray - cv2.erode(gray, kernel=np.ones((5,5)),iterations=5)

// (Fri) Mail the progress (pic dumps)


///////////////
# Notes
Resizes in algo

template.py
	template = resize_util(template, int(template.shape[1]/templ_scale_down))

show()
 	img = resize_util(orig,display_width) if resize else orig

getBestMatch
    templ_scaled = imutils.resize(template_eroded_sub, height = int(h*s))

getROI
    image_norm = resize_util(image_norm, uniform_width_hd)
    # Resize back to uniform height
    warped_image_eroded_sub = resize_util(warped_image_eroded_sub, uniform_width_hd)
    warped_image_norm = resize_util(warped_image_norm, uniform_width_hd)
    # resize to best scale
	templ = imutils.resize(template_eroded_sub, height = int(template_eroded_sub.shape[0]*best_scale))

	# template fit resizing
    img = resize_util(img,1846,1500)

testImg
	img = resize_util(img,uniform_width_hd)
///////////////

After MS:
- Refactor readResponse
//- Shifting ideation 
- Apply DFT and IFT on cropped one just to see.
- Get more test data : On which template shifts currently
	>

Excess:
	Mechanisms to check if circles found form a rectangle-like shape
	Defeat the bossbg.jpg	
	3D viz (online) of this templateMatch output(, Sobel eroded blobs) to see the peaks

Shifting - 
Problem: [Nonlinear Distortion] There's an uneven shift(mainly horizontal) of order of 2-3 pixels in the Qbox columns

Nope- Rect level soln
	> Easier to align
	> Assumes there's a bounding rect present for alignment
	> Still the rects are long, nonlinear distortion would still mess it up	

Qbox level soln
	Naive approach (inefficient here)
		> Take each QBlock, move it around in 20% area and return the pos where an index is maximum. 
			The index can be - 
			1. Correlation : Error chances significant as there are smaller box lines that also correlate 
			2. Correlation on Eroded image : Gotta try
				It is taken with white color anyway: so just take max white value.
		_/	3. Correlation on Gradient image : More consistent
	
	Different approach 1
		> We'd always have partially filled(gray or black) Qboxes, move them individually towards the black area
			- wont work on noise due to xerox bg!

** > readResponse works better on this (moderately) eroded_sub?
- Nope, the unfilled ones also become dark, only the boundary around filled ones can be utilised for something awesome


16 Mar 19
Major Changes:
	// Implemented shifting in align file
	Threshold from gap needs to be columnwise- Xerox grays are pretty bad
		- e.g. on HE_Bangalore_01 Xeroxed sheet it works miserably.
	--> Qblock class shall help here.

Minor Changes:
	Resize page(>>BOTH W & H) to fixed size after Warp layer 1 
	==> No need of scaled checking?! : Still doing precautionary

19 Mar 19
// Implemented (naive) shifting in utils

Minor: 
// Separated JSONs from template.py 
// Rather, removed it-  scalePts was not acting since rect{} was introduced, also updated it with int() on pts to support fractional scaling

Some dilemmas and decisions over them-
> Template json contents : Should 'qblockDims' be written in the file or calculated from Gaps already present there
	--> Minimal redundancy should be followed, so calculate. 
	--> Giving it in file also introduces interdependencies - changing qNos reqs recalculating qblockDims again.
	<-- But won't it be fixed for the template? And more accurate than calculating using gaps?

> Making QBlock class :
	<-- Keeping as array was simple, now more loops introduced
	--> The paradigm was demanded on need by my subcons, gotta trust my guts this time.


# Let's Apply adaptive threshold QBlock-wise.
# >> Nope, do column-wise or don't - 
# Then need to separate the Qs array - doable, but extensible?
# >> No need! You just need QVals, can get it cumulating via QBlocks too, get it as you find shifts

Wish me clarity!!
>> (From Speech TA) 7x1 kernel erosion is damn perfect suggestion ==> Makes use of real morphology power
>> Not now, sometime later! - My Sobel be useful tho (feed the stumbling)
--> This is why you should work on thinking clearly first before acting.  

Things that should have clicked(altho not useful everytime) when seen first time!
--> Denoise first using morphology! ( Well, didn't work as expected now!)
--> Blur then denoise - nop

Sobel : 
	is an approximation to derivative _// 
	sign of output doesn't matter _//
	(1,0) means horizontal gradient _//


21 Mar 19
// Implemented proper shifting in utils
	Nope, there's more accurate approach - Qval correlation instead of QBlock be most accurate
	- Area between Qboxes be checked : use a mask! 
	>> also useful for future changes : if decided to align vertically as well
--> Further accurate: approach4 - move towards the blob - use MOMENTS!
	- move towards centroid until direction changes.

Minor:
	Nope- Q object now has endpts and a mask for aligning 
		QBlock has cols attribute for vertical cols (even for orient='H') and No mask needed practically

- Test all on dark xerox now.
	- even white xeroxes making probs now, need to change aligning method to more robust
	
- Apply DFT and IFT on cropped one just to see.
Design the demo scenario now.